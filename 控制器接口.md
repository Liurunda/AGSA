# 控制器接口

控制器的接口分为控制器-后端，控制器-judger，控制器-游戏逻辑，控制器-编译器四个部分

## 控制器-后端
控制器与后端的交互通过websocket进行，后端作为server，控制器作为client。  
控制器与后端的常规交互信息均为字符串：  

> "Ready": 控制器初始化完成，发送"Ready"到后端表示准备完成。后端应返回字符串"Ready"回应。  
> "Request_For_Commands": 控制器每隔1秒钟向后端拉取指令。控制器应返回的值为：
>> "No_Commands": 无新的命令。  
>> "Start_Game_Command": 新的比赛请求。发送该指令后，控制器应当继续发送一个json文件，格式为：  
>>> "Game_ID": "xxx", "Team_Numbers": "xxx", "Team_A": "{"Player_Numbers": "xxx", "Player_A": "[AI_Token\Human_Player]", ...}", ...  
>>> Game_ID是游戏标识符，唯一确定一局游戏用；  
>>> Team_Numbers：队伍数量，对于大部分游戏为2；  
>>> Team_？：队伍，储存一个json文件，里面包括队伍人数、队伍AI的token(若为真人玩家，则把token换为字符串"Human_Player")。
>>
>> "Complie_Command": 编译指令。发送指令后，控制器应当继续发送一个json文件，格式为：  
>>> "File_Number": "xxx", "File_A": "[File_Path]", ...
>
> "Game_Ended"：游戏结束，将返回一个json文件  
>> "Errors": "[error]", "Battle_Info": "[File_Path]"  
>> Errors：若游戏异常中止，则error为异常信息，否则为"None"；
>> Battle_Info：回放文件路径。
>
> "Compile_Ended"：编译结束，将返回一个json文件
>> “File_Name": "[File_Name]", "Errors": "[error]"
>> File_Name：编译完成的文件名字；
>> Errors：若该文件编译时出错，则error为异常信息，否则为"None"。
>
> "Disconnect"：控制器收到退出指令，与后端断开链接。后端的行为由zah决定。

局面信息的传递暂且不管，等决定是由judger直接控制还是统一交给后端时再决定

## 控制器-judger
控制器通过subprocess.Popen()方法运行judger的脚本文件，同时将judger的标准输入输出接到控制器中，由控制器负责judger与游戏逻辑的交互。  

**judger调用方式：**
> python3 [ Judger_Path ] [ Player_Number ] [ AI_Path/Human_Player ]...

## 控制器-游戏逻辑
游戏逻辑需要提供一个可执行文件，控制器通过subprocess.Popen()方法运行游戏逻辑的可执行文件，同时将游戏逻辑的标准输入输出接到控制器中，由控制器负责judger与游戏逻辑的交互

**游戏逻辑调用方式：**
> [ Logic_Path ] [ Player_Number ]

    在judger和游戏逻辑向控制器写入文本的时候，需要在写完文本之后调用flush清空缓冲区，否则控制器可能无法渡入写入的文本，从而造成judger和游戏逻辑的强行中止。

## 控制器-编译器
控制器只负责运行编译器，不与编译器交互

**编译器调用方式：** 参考编译器使用方法